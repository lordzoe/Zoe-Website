<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Model Visualizer</title>
  <style>
    body {
      display: flex;
      flex-direction: row;
      font-family: Arial, sans-serif;
    }
    .sidebar {
      width: 220px;
      padding: 20px;
      background: #f4f4f4;
      border-right: 1px solid #ccc;
    }
    .sidebar h3 {
      margin-top: 0;
    }
    .sidebar button {
      width: 100%;
      margin: 5px 0;
      padding: 10px;
      font-size: 14px;
    }
    .main-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #fff;
    }
    #datasetButtons {
      margin: 10px;
    }
    canvas {
      border: 1px solid #000;
    }
    .parameters {
      width: 500px;
      margin-top: 10px;
      background: #f8f8f8;
      padding: 10px;
      font-family: monospace;
      font-size: 13px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
    }
    /* Confusion matrix styling */
    table.confusion-matrix {
      border-collapse: collapse;
      margin-top: 10px;
    }
    table.confusion-matrix td {
      width: 80px;
      height: 60px;
      text-align: center;
      vertical-align: middle;
      font-weight: bold;
      color: #000;
      border: 1px solid #aaa;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <h3>Select Dataset</h3>
    <div id="datasetButtons">
      <button onclick="selectDataset('A')">Dataset A (Linear)</button>
      <button onclick="selectDataset('B')">Dataset B (Circular)</button>
      <button onclick="selectDataset('C')">Dataset C (Noisy)</button>
    </div>

    <h3>Select Model</h3>
    <button onclick="selectModel('logistic')">Logistic Regression</button>
    <button onclick="selectModel('knn')">K-Nearest Neighbors (KNN)</button>
    <button onclick="selectModel('dt')">Decision Tree</button>
    <button onclick="selectModel('svm')">Support Vector Machine (SVM)</button>
    <button onclick="selectModel('perceptron')">Perceptron</button>
    <button onclick="selectModel('ensemble')">Ensemble</button>
  </div>

  <div class="main-content">
    <canvas id="modelCanvas" width="500" height="500"></canvas>
    <div id="dtControls" style="display: none; margin-top: 10px;">
        <label for="depthSlider">Tree Depth: <span id="depthValue">2</span></label><br>
        <input type="range" min="1" max="5" value="2" id="depthSlider" onchange="updateDepth(this.value)">
    </div>
    <div id="parameterBox" class="parameters"></div>
  </div>

  <script>
    const canvas = document.getElementById("modelCanvas");
    const ctx = canvas.getContext("2d");
    const paramBox = document.getElementById("parameterBox");
    const W = canvas.width;
    const H = canvas.height;

    let currentModel = 'logistic';
    let currentDataset = 'A';

    let maxTreeDepth = 2;
    const depthSlider = document.getElementById('depthSlider');
    const depthValue = document.getElementById('depthValue');

    // The dataset we train/predict on
    let data = [];

    // Weights for different models
    let perceptronWeights = Array.from({ length: 6 }, () => Math.random() - 0.5);
    let perceptronHiddenWeights = Array.from({ length: 6 }, () => Math.random() - 0.5);
    let dtModel = null;
    let logisticWeights = [Math.random(), Math.random(), Math.random()];
    let svmWeights = [Math.random(), Math.random(), Math.random()];

    /***********************
     * Decision Tree Setup *
     **********************/

    // 1) Slider callback
    function updateDepth(val) {
      maxTreeDepth = parseInt(val);
      depthValue.textContent = val;
      if (currentModel === 'dt') {
        trainDecisionTree();
        drawDecisionBoundary();
        drawDataset();
        updateParameterDisplay();
      }
    }

    // 2) Convert the tree structure to text
    function stringifyTree(node, indent = 0) {
      if (typeof node === 'number') {
        return ' '.repeat(indent) + `Leaf: ${node}\n`;
      }
      let str = ' '.repeat(indent) + `if (${node.feature} <= ${node.threshold.toFixed(2)})\n`;
      str += stringifyTree(node.left, indent + 2);
      str += ' '.repeat(indent) + `else\n`;
      str += stringifyTree(node.right, indent + 2);
      return str;
    }

    // 3) Build the tree
    function buildSimpleTree(dataset, depth = 0, maxDepth = 2) {
      // If we are at or beyond max depth or have few data => leaf
      if (depth >= maxDepth || dataset.length < 4) {
        const majority = dataset.reduce((acc, p) => acc + p.label, 0) / dataset.length > 0.5 ? 1 : 0;
        return majority;
      }
      const split = getBestSplit(dataset);
      const [left, right] = splitData(dataset, split.feature, split.threshold);
      // Recurse
      return {
        feature: split.feature,
        threshold: split.threshold,
        left: buildSimpleTree(left, depth + 1, maxDepth),
        right: buildSimpleTree(right, depth + 1, maxDepth)
      };
    }

    // 4) Actually train on the entire dataset (no random subset)
    function trainDecisionTree() {
      dtModel = buildSimpleTree(data, 0, maxTreeDepth);
    }

    // 5) Find best split
    function getBestSplit(dataset) {
      const classValues = [...new Set(dataset.map(p => p.label))];
      let bestGini = Infinity;
      let bestFeature = null;
      let bestThreshold = null;

      for (const feature of ['x', 'y']) {
        const values = dataset.map(p => p[feature]);
        for (const t of values) {
          const groups = splitData(dataset, feature, t);
          const gini = giniImpurity(groups, classValues);
          if (gini < bestGini) {
            bestGini = gini;
            bestFeature = feature;
            bestThreshold = t;
          }
        }
      }
      return { feature: bestFeature, threshold: bestThreshold };
    }

    function splitData(dataset, feature, threshold) {
      const left = dataset.filter(p => p[feature] <= threshold);
      const right = dataset.filter(p => p[feature] > threshold);
      return [left, right];
    }

    function giniImpurity(groups, classes) {
      const nInstances = groups[0].length + groups[1].length;
      let gini = 0.0;
      for (const group of groups) {
        const size = group.length;
        if (size === 0) continue;
        let score = 0.0;
        for (const classVal of classes) {
          const proportion = group.filter(p => p.label === classVal).length / size;
          score += proportion * proportion;
        }
        gini += (1.0 - score) * (size / nInstances);
      }
      return gini;
    }

    /*********************
     * Model & Data Setup
     *********************/
     function selectModel(model) {
        currentModel = model;
        const dtControls = document.getElementById('dtControls');
        if (model === 'dt') {
          dtControls.style.display = 'block';
          trainDecisionTree();
        } else {
          dtControls.style.display = 'none';
        }
        ctx.clearRect(0, 0, W, H);
        drawDecisionBoundary();
        drawDataset();
        updateParameterDisplay();
      }

    function selectDataset(ds) {
      currentDataset = ds;
      resetAndVisualize();
    }

    /*********************
     * Generate Datasets
     *********************/
    function generateDatasetA() {
      data = [];
      for (let i = 0; i < 100; i++) {
        const x = Math.random();
        const y = Math.random();
        // label=1 if y>x
        const label = y > x ? 1 : 0;
        data.push({ x, y, label });
      }
    }

    function generateDatasetB() {
      data = [];
      // center class
      for (let i = 0; i < 50; i++) {
        const r = Math.random() * 0.15;
        const angle = Math.random() * 2 * Math.PI;
        data.push({
          x: 0.5 + r * Math.cos(angle),
          y: 0.5 + r * Math.sin(angle),
          label: 1
        });
      }
      // ring class
      for (let i = 0; i < 50; i++) {
        const r = 0.25 + Math.random() * 0.15;
        const angle = Math.random() * 2 * Math.PI;
        data.push({
          x: 0.5 + r * Math.cos(angle),
          y: 0.5 + r * Math.sin(angle),
          label: 0
        });
      }
    }

    function generateDatasetC() {
      data = [];
      for (let i = 0; i < 100; i++) {
        const x = Math.random();
        const y = Math.random();
        const ideal = y > x ? 1 : 0;
        // 20% chance to flip
        const label = Math.random() < 0.2 ? 1 - ideal : ideal;
        data.push({ x, y, label });
      }
    }

    function generateDataset() {
      if (currentDataset === 'A') generateDatasetA();
      else if (currentDataset === 'B') generateDatasetB();
      else generateDatasetC();
    }

    /***********************
     * Train Other Models
     **********************/
    function trainPerceptron() {
      for (const point of data) {
        const inputs = [point.x, point.y, point.x * point.y, point.x ** 2, point.y ** 2, 1];
        const hidden = tanh(dot(inputs, perceptronHiddenWeights));
        const output = sigmoid(hidden * perceptronWeights[0] + perceptronWeights[5]);
        const error = point.label - output;
        for (let i = 0; i < 5; i++) {
          perceptronWeights[i] += 0.05 * error * hidden;
          perceptronHiddenWeights[i] += 0.05 * error * perceptronWeights[0] * (1 - hidden ** 2) * inputs[i];
        }
        perceptronWeights[5] += 0.05 * error;
      }
    }

    function trainLogistic() {
      for (const point of data) {
        const x = point.x;
        const y = point.y;
        const z = logisticWeights[0] * x + logisticWeights[1] * y + logisticWeights[2];
        const pred = sigmoid(z);
        const error = pred - point.label;
        logisticWeights[0] -= 0.1 * error * x;
        logisticWeights[1] -= 0.1 * error * y;
        logisticWeights[2] -= 0.1 * error * 1;
      }
    }

    function trainSVM() {
      for (const point of data) {
        const x = point.x;
        const y = point.y;
        const label = point.label === 1 ? 1 : -1;
        const margin = label * (svmWeights[0] * x + svmWeights[1] * y + svmWeights[2]);
        if (margin < 1) {
          svmWeights[0] += 0.01 * label * x;
          svmWeights[1] += 0.01 * label * y;
          svmWeights[2] += 0.01 * label;
        }
      }
    }

    /****************
     *  Prediction  *
     ****************/
    function evaluateDecisionTree(x, y, node = dtModel) {
      if (typeof node === 'number') return node;
      const val = (node.feature === 'x') ? x : y;
      if (val <= node.threshold) return evaluateDecisionTree(x, y, node.left);
      else return evaluateDecisionTree(x, y, node.right);
    }

    function predict(x, y) {
      switch (currentModel) {
        case 'logistic': return sigmoid(logisticWeights[0]*x + logisticWeights[1]*y + logisticWeights[2]);
        case 'knn': return knnPredict(x, y);
        case 'dt': return evaluateDecisionTree(x, y);
        case 'svm': return sigmoid(svmWeights[0]*x + svmWeights[1]*y + svmWeights[2]);
        case 'perceptron': {
          const features = [x, y, x*y, x**2, y**2, 1];
          const hidden = tanh(dot(features, perceptronHiddenWeights));
          return sigmoid(hidden * perceptronWeights[0] + perceptronWeights[5]);
        }
        case 'ensemble': {
          return (
            sigmoid(logisticWeights[0]*x + logisticWeights[1]*y + logisticWeights[2]) +
            knnPredict(x, y) +
            sigmoid(svmWeights[0]*x + svmWeights[1]*y + svmWeights[2])
          ) / 3;
        }
        default: 
          return 0.5;
      }
    }

    /************************
     *   Utility Functions
     ************************/
    function sigmoid(z) {
      return 1 / (1 + Math.exp(-z));
    }
    function tanh(z) {
      return Math.tanh(z);
    }
    function dot(a, b) {
      return a.reduce((sum, ai, i) => sum + ai * b[i], 0);
    }

    function knnPredict(x, y, k = 3) {
      return data
        .map(p => ({ dist: (p.x - x)**2 + (p.y - y)**2, label: p.label }))
        .sort((a, b) => a.dist - b.dist)
        .slice(0, k)
        .reduce((sum, p) => sum + p.label, 0) / k;
    }

    /************************
     *   Drawing & UI
     ************************/
    function drawDataset() {
      for (const point of data) {
        ctx.beginPath();
        ctx.arc(point.x * W, point.y * H, 5, 0, 2 * Math.PI);
        ctx.fillStyle = (point.label === 1) ? 'green' : 'red';
        ctx.fill();
      }
    }

    function drawDecisionBoundary() {
      for (let x = 0; x < W; x += 4) {
        for (let y = 0; y < H; y += 4) {
          const normX = x / W;
          const normY = y / H;
          const prediction = predict(normX, normY);
          ctx.fillStyle = (prediction > 0.5) ? '#90ee90' : '#ffb6b6';
          ctx.fillRect(x, y, 4, 4);
        }
      }
    }

    /***********************************************
     *  Metrics: F1, Accuracy, Precision, Recall
     *  + Confusion Matrix
     ***********************************************/
    function computeMetrics() {
      let TP = 0, TN = 0, FP = 0, FN = 0;
      for (const p of data) {
        const pred = predict(p.x, p.y) > 0.5 ? 1 : 0;
        if (p.label === 1 && pred === 1) TP++;
        else if (p.label === 0 && pred === 0) TN++;
        else if (p.label === 0 && pred === 1) FP++;
        else if (p.label === 1 && pred === 0) FN++;
      }
      const total = data.length;
      const accuracy = (TP + TN) / total;
      const precision = (TP + FP) === 0 ? 0 : TP / (TP + FP);
      const recall = (TP + FN) === 0 ? 0 : TP / (TP + FN);
      const f1 = (precision + recall) === 0 ? 0 : 2*(precision*recall)/(precision+recall);
      return {TP, TN, FP, FN, accuracy, precision, recall, f1};
    }

    function colorTPorTN(value) {
      // from 0..60 => green
      const v = Math.min(value, 60);
      const ratio = v / 60;
      const r = Math.floor(255*(1-ratio));
      const g = Math.floor(255*ratio);
      return `rgb(${r},${g},0)`;
    }
    function colorFPorFN(value) {
      // from 0..30 => red
      const v = Math.min(value, 30);
      const ratio = v / 30;
      const r = Math.floor(255*ratio);
      const g = Math.floor(255*(1-ratio));
      return `rgb(${r},${g},0)`;
    }

    function buildConfusionMatrixHTML(TP, TN, FP, FN) {
      const total = TP + TN + FP + FN;
      const tpPercent = ((TP / total) * 100).toFixed(2);
      const tnPercent = ((TN / total) * 100).toFixed(2);
      const fpPercent = ((FP / total) * 100).toFixed(2);
      const fnPercent = ((FN / total) * 100).toFixed(2);

      const tpColor = colorTPorTN(parseFloat(tpPercent));
      const tnColor = colorTPorTN(parseFloat(tnPercent));
      const fpColor = colorFPorFN(parseFloat(fpPercent));
      const fnColor = colorFPorFN(parseFloat(fnPercent));

      return `
        <div style="display: flex; flex-direction: column; align-items: center; margin-top: 10px;">
          <div style="font-weight: bold; margin-bottom: 4px;">Confusion Matrix</div>
          <table class="confusion-matrix">
            <tr>
              <td style="background:${tpColor}">TP<br>${tpPercent}%</td>
              <td style="background:${fpColor}">FP<br>${fpPercent}%</td>
            </tr>
            <tr>
              <td style="background:${tnColor}">TN<br>${tnPercent}%</td>
              <td style="background:${fnColor}">FN<br>${fnPercent}%</td>
            </tr>
          </table>
        </div>
      `;
    }

    /*****************************
     *  reset & re-draw pipeline
     *****************************/
    function resetAndVisualize() {
      generateDataset();
      if (currentModel === 'dt') {
        trainDecisionTree();
      }
      ctx.clearRect(0, 0, W, H);
      drawDecisionBoundary();
      drawDataset();
      updateParameterDisplay();
    }

    /*****************************
     *  Animation loop
     *****************************/
    function loop() {
      // Train only these models in real time
      if (currentModel === 'perceptron') trainPerceptron();
      if (currentModel === 'logistic') trainLogistic();
      if (currentModel === 'svm') trainSVM();

      ctx.clearRect(0, 0, W, H);
      drawDecisionBoundary();
      drawDataset();
      updateParameterDisplay();

      requestAnimationFrame(loop);
    }

    function updateParameterDisplay() {
      let text = `Model: ${currentModel}\n`;
      if (currentModel === 'dt') {
        text += `\nTree Depth: ${maxTreeDepth}\n`;
        text += `\nTree Structure:\n${stringifyTree(dtModel)}`;
      }
      // Add code if you want other models to show weights, etc.

      // Metrics
      const {TP, TN, FP, FN, accuracy, precision, recall, f1} = computeMetrics();
      text += `\n\nPerformance Metrics:\n`;
      text += `Accuracy: ${(accuracy*100).toFixed(2)}%\n`;
      text += `Precision: ${(precision*100).toFixed(2)}%\n`;
      text += `Recall: ${(recall*100).toFixed(2)}%\n`;
      text += `F1 Score: ${(f1*100).toFixed(2)}%\n`;

      // Confusion matrix
      const cmHTML = buildConfusionMatrixHTML(TP, TN, FP, FN);

      paramBox.innerHTML = text.replace(/\n/g, '<br>') + cmHTML;
    }

    // Initialize with dataset A by default
    selectDataset('A');
    loop();
  </script>
</body>
</html>
